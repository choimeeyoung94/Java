# Java

## Primitivie Type
- 기본 타입을 의미한다
- 값만 저장하는 타입, 객체와 구별되는 데이터 타입
- 8가지 기본 타입이 있다 (boolean, byte, short, int, long, float, double, char)

### 데이터 타입과 크기와 표현할 수 있는 범위
1.byte  1바이트 (-128 ~ 127)
2.short 2바이트 (-32768 ~ 32767)
3.int   4바이트 (대표 정수 타입)
4.long  8바이트


## 비트와 바이트
- 비트: 0 또는 1이르 저장할 수 있는 최소 저장단위
- 바이트: 8비트로 구성된 메모리의 최소 저장 단위

### 비트로 표현 가능한 데이터 범위
- 4비트로 가능한 데이터 범위: -8 ~ 7
- 8비트로 가능한 데이터 범위: -128 ~ 127
- N비트로 가능한 데이터 범위: -2의 (N-1)제곱 ~ 2의 (n-1)제곱 - 1


## Reference Type
- 참조 타입
- 데이터가 저장된 메모리의 참조값(주소값)을 저장하는 타입
- 종류 : 클래스 타입, 배열 타입, 인터페이스, 열거 타입

## 자바 메모리 구조
- 자바 프로그램이 실행 되면 JVM이 여러 메모리 영역을 사용한다
- 자바 프로그램을 구성하는 변수, 메소드, 클래스 등은 메모리에 저장된다

### 스택 영역 : 변수가 저장되는 영역
### 힙 영역: 객체, 배열 등이 저장되는 영역
### 메소드 영역: 클래스 정보, static 변수 등이 저장되는 영역

### 메모리 구조
- 1바이트 마다 참조값(주소값)을 부여한다
- 참조값은 16진수로 표기 (0x, 0X로 시작하는 숫자)
- 자바는 실제 참조값(메모리의 주소값)을 직접 확인하거나 수정할 수 없다

## Casting
- 데이터 타입 변환의 한 종류
- 직접 변호나할 타입을 명시하는 명시적 변환 과정
- 큰 데이터 타입을 작은 데이터 타입으로 강제 변환하는 과정

```
 // int -> byte 변환
 int i = 256;       //                       이진값(비트값) : 100000000
 byte b = (byte)i;

  // double -> long 변환
  double d = 1.9;
  long l = (long)d; // ------- Casting (실수 -> 정수 변환 시 소수 아래는 모두 손실)

  // int -> char
  int iNum = 48; // 48('0'), 65('A'), 97('a') 32('')
  char f = (char)iNum; // Casting (정수 -> 문자 변환시 정수를 코드값으로 가지는 문자로 변환)
  ```

### Promotion
- 데이터 타입 변환의 한 종류
- 자동으로 수행하는 타입 변환
- 작은 데이터 타입을 큰 데이터 타입으로 자동 변환하는 과정
- 크기가 아닌 데이터 표현 범위가 기준이다
```
 // 예시1) int -> long
int i = 10;
long l = i; // Promotion 자동으로 4바이트 짜리 int 값이 8바이트 짜리 long으로 바뀐다 (자동 변환)
double d = l; // Promotion (자동 변환)

char ch = '가'; 
int iNum = ch;
```

## 배열
- 스택 영역에 참조 변수가 생성된다

### 배열 초기화
#### 1. 배열 선언시 초기화
```
String[] frontEnd = {"HTML", "CSS", "JavaScript", "React"};
```

#### 2. 배열 선언과 초기화를 두개의 코드로 분리
```
String[] backEnd;
backEnd = new String[] { "Java", "JSP/Servlet", "SPRING", "MySQL" };
```

#### 2차원 배열
- 1차원 배열이 여러개 존재하는 경우 이 1차원 배열을 합친것

```
// 2차원 배열 선언
String[][] seats;

// 배열 생성 (1차원 배열을 만드는 작업)
seats = new String[3][]; // 1차원 배열이 3개이다

// 1차원 배열 생성 (1차원 배열의 길이를 만드는 작업)
seats[0] = new String[2]; // 첫번째 1차원 배열의 길이는 2이다 seats[0]이 1차원 배열의 이름
seats[1] = new String[5]; // 두번째 1차원 배열의 길이는 5이다 seats[1]이 1차원 배열의 이름
seats[2] = new String[4]; // 세번째 1차원 배열의 길이는 4이다 seats[2]이 1차원 배열의 이름

// 2차원 배열 요소 사용 (인덱스를 2개 사용 : 몇 번째 1차원 배열인가? 1차원 배열 내 몇 번째 요소인가?)
seats[0][0] = "이동욱";
seats[0][1] = "신성수";

seats[1][0] = "이유천";
seats[1][1] = "조기완";
seats[1][2] = "최미영";
seats[1][3] = "박진성";
seats[1][4] = "김민석";

seats[2][0] = "유비";
seats[2][1] = "이창민";
seats[2][2] = "권형택";
seats[2][3] = "김경진";
```
   /*
    * [Stack]               Reference(참조값)
    * +-------------------+
    * | seats    : 0x100  |
    * +-------------------+
   
    * 
    * [Heap]   
    * | ...               |
    * +-------------------+
    * | seats[0] : 0xAAA  | 0x100
    * +-------------------+
    * | seats[1] : 0xBBB  | 0x104
    * +-------------------+
    * | seats[2] : 0xCCC  | 0x108
    * +-------------------+
    * |  ...              |               [String Constant Pool] -> 문자열 리터럴("")로 생성한 문자열이 저장되는 곳 (JVM이 관리한다)
    * +-------------------+                      +--------+
    * | seats[0][0] : 0x1 | 0xAAA                | 이동욱 | 0x1
    * +-------------------+                      +--------+
    * | seats[0][1] : 0x2 |                      | 신성수 | 0x2
    * +-------------------+                      +--------+
    * | ...               |
    * +-------------------+                      +--------+
    * | seats[1][0] : 0x3 | 0xBBB                | 이유천 | 0x3
    * +-------------------+                      +--------+
    * | seats[1][1] : 0x4 |                      | 조기완 | 0x4
    * +-------------------+                      +--------+
    * | seats[1][2] : 0x5 |                      | 최미영 | 0x5
    * +-------------------+                      +--------+
    * | seats[1][3] : 0x6 |                      | 박진성 | 0x6
    * +-------------------+                      +--------+
    * | seats[1][4] : 0x7 |                      | 김민석 | 0x7
    * +-------------------+                      +--------+
    * | ...               |
    * +-------------------+                      +--------+
    * | seats[2][0] : 0x8 | 0xCCC                | 유  비 | 0x8
    * +-------------------+                      +--------+
    * | seats[2][1] : 0x9 |                      | 이창민 | 0x9
    * +-------------------+                      +--------+
    * | seats[2][2] : 0xA |                      | 권형택 | 0xA
    * +-------------------+                      +--------+
    * | seats[2][3] : 0xB |                      | 김경진 | 0xB
    * +-------------------+                      +--------+
    * | ...               |
    * +-------------------+
    */

- seats 배열의 참조값은  0x100이다
- 0x100 참조값을 따라가 보면 seats[0] 배열의 참조값 0xAAA이 들어있다
- 0xAAA 참조값을 따라가 보면 seats[0][0] 배열의 참조값 0x1이 들어있다
- 0x1 참조값을 따라가 보면 데이터 "이동욱"이 들어가 있다



## 클래스
- 클래스는 값(필드)와 기능(메서드)을 가지는 코드 블록
- 클래스가 가지고 있는 값(필드)와 기능(메서드)을 사용하려면 일반적으로 해당 클래스를 타입으로 가지는 객체(인스턴스)를 생성해야 한다
- 생성된 객체를 사용해서 값(필드)을 사용하거나 기능(메소드)을 호출한다
```
 // 클래스 Book 타입의 객체 선언(참조변수 선언)
  Book book1;

  // book1 객체 생성 (인스턴스화를 통해서 인스턴스가 생성된다)
  book1 = new Book();
    
  // book1 객체 정보 확인
  System.out.println(book1);

```

## 메소드
```
반환타입 메소드명(매개변수1, 매개변수2,...) {
  메소드 본문 코드
  return 반환값
}
```
- 반환타입과 반환값이 명시된다
- 메소드이름만 작성해서 사용한다
- void 반환이 없다
- 메소드명 camelCase

```
 void methodE(int first, int...arrays) {   
    System.out.println("methodE: " +first + ","
        + " " +  Arrays.toString(arrays));
  }
 ```
- 한개 이상의 정수 값을 전달 받는다
- first 변수에 첫번째 값이 전달된다
- int...arrays에 나머지 값들이 전달된다

## 필드
- 클래스가 가지는 값
- 클래스가 선언하 변수 (일반 지역변수와 구분해서 필드라고 부른다)
- 클래스에 포함된 모든 메소드는 필드를 사용할 수 있다
- 일반 지역변수와 달리 선언만 하면 자동으로 초기화 된다(0, false, null 등)

## 생성자
- 객체(인스턴스)를 생성할 때 호출하는 특별한 메소드
- 오직 객체(인스턴스) 생성할 때만 호출할 수 있다
- 객체 생성 키워드 new 뒤에서 생성자를 호출한다
- 생성자의 이름은 클래스의 이름과 반드시 같아야 한다
- 일반 메소드와 달리 반환타입이 존재하지 않는다
- 일반 메소드처럼 메소드 오버로딩이 가능하다

### 디폴트 생성자
- 매개변수가 없는 생성자
- 클래스에 생성자를 하나도 정의하지 않으면 자바 컴파일러는 매개변수가 없고 본문이 비어있는 디폴트 생성자를 만든다
- 클래스에 생성자를 하나 이상 정의하면 디폴트 생성자는 더 이상 자동으로 생성되지 않는다


